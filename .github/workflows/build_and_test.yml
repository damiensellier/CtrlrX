name: Pamplejuce

on:
  workflow_dispatch: # lets you run a build from the UI
    inputs:
      debug_enabled:
        type: boolean
        description: 'Run the build with tmate debugging enabled (https://github.com/marketplace/actions/debugging-with-tmate)'
        required: false
        default: false
  push:
  pull_request:

# When pushing new commits, cancel any running builds on that branch
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

env:
  BUILD_TYPE: Release
  BUILD_DIR: build
  DISPLAY: :0 # linux pluginval needs this
  HOMEBREW_NO_INSTALL_CLEANUP: 1
  SCCACHE_GHA_ENABLED: true
  SCCACHE_CACHE_MULTIARCH: 1
  IPP_DIR: C:\Program Files (x86)\Intel\oneAPI\ipp\latest\lib\cmake\ipp

defaults:
  run:
    shell: bash

# jobs are run in parallel on different machines
# all steps run in series
jobs:
  build_and_test:
    # don't double run on PRs
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name != github.event.pull_request.base.repo.full_name
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.os }}
    env:
      HAVE_DEV_ID_APP_CERT: ${{ secrets.DEV_ID_APP_CERT != '' }}
      HAVE_DEV_ID_INSTALLER_CERT: ${{ secrets.DEV_ID_INSTALLER_CERT != '' }}
      HAVE_AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET != '' }}
    strategy:
      fail-fast: false # show all errors for each platform (vs. cancel jobs on error)
      matrix:
        include:
          - name: Linux
            os: ubuntu-24.04
            pluginval-binary: ./pluginval
            # FIX: Explicitly define JUCE_LINUX for the build to enable conditional BFD includes in libr.h/c
            extra-flags: -G Ninja -DJUCE_LINUX=1
          - name: macOS
            os: macos-14
            pluginval-binary: pluginval.app/Contents/MacOS/pluginval
            extra-flags: -G Ninja -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          - name: Windows
            os: windows-2022
            pluginval-binary: ./pluginval.exe

    steps:
      # Setup MSVC toolchain and developer command prompt (Windows)
      - uses: ilammy/msvc-dev-cmd@v1

      # Use clang on Linux so we don't introduce a 3rd compiler (Windows and macOS use MSVC and Clang)
      - name: Set up Clang
        if: runner.os == 'Linux'
        uses: egor-tensin/setup-clang@v1

      # This also starts up our "fake" display (Xvfb), needed for pluginval
      - name: Install JUCE's Linux Deps
        if: runner.os == 'Linux'
        # Thanks to McMartin & co https://forum.juce.com/t/list-of-juce-dependencies-under-linux/15121/44
        run: |
          sudo apt-get update && sudo apt install libasound2-dev libx11-dev libxinerama-dev libxext-dev libfreetype6-dev libglu1-mesa-dev xvfb ninja-build
          sudo /usr/bin/Xvfb $DISPLAY &

      - name: Install IPP (Windows)
        if: (runner.os == 'Windows')
        run: |
          nuget install intelipp.static.win-x64 -Version 2022.2.0.575

      - name: Install Ninja (Windows)
        if: runner.os == 'Windows'
        run: choco install ninja

      - name: Install macOS Deps
        if: ${{ matrix.name == 'macOS' }}
        run: brew install osxutils

      # This block can be removed once 15.1 is default (JUCE requires it when building on macOS 14)
      - name: Use latest Xcode on system (macOS)
        if: ${{ matrix.name == 'macOS' }}
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install CtrlrX Deps and Check libsframe.so.2
        run: |
          echo "OS: $RUNNER_OS"
          echo "Current working directory: $PWD"
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt install -y binutils-dev libboost-dev libcurl4-gnutls-dev libgl1-mesa-dev libglapi-mesa libiberty-dev libsframe1 libudev-dev libxcursor-dev libxrandr-dev xorg-dev

            echo "--- Verifying libsframe soname ---"
            LSFRAME_PATH=$(find /usr/lib/ /lib/ -name "libsframe.so.2" -print -quit 2>/dev/null)

            if [ -n "$LSFRAME_PATH" ]; then
              echo "Success: Found libsframe.so.2 at $LSFRAME_PATH"
              # Add the library path to LD_LIBRARY_PATH (may not be strictly necessary, but safe)
              echo "LD_LIBRARY_PATH=$(dirname "$LSFRAME_PATH"):\$LD_LIBRARY_PATH" >> $GITHUB_ENV
            else
              
              # CRITICAL WARNING: If .so.2 is not found, it means the build might link to .so.1
              echo "WARNING: libsframe.so.2 not found on ubuntu-24.04 runner after installing libsframe1."
              echo "Installed libsframe files:"
              find /usr/lib/ /lib/ -name "libsframe.so*" 2>/dev/null
              
              # If you NEED .so.2, you'd have to use a PPA or build binutils from source here.
              # For this example, we proceed with the installed version, but the logs will alert you.
              # If you encounter runtime errors on a system requiring .so.2, you must update the base image or manually upgrade binutils.
              
              fi
              echo "----------------------------------"
            
            elif [ "$RUNNER_OS" == "Windows" ]; then
            # to not clutter the build step logs:
            pushd ./Source/Misc/
            unzip boost/boost.zip
            popd
          elif [ "$RUNNER_OS" == "macOS" ]; then
            brew install boost
            # somehow cmake doesn't pick up on /usr/local/include/boost/ ... maybe have to set it in the .jucer project
            pushd ./Source/Misc/
            unzip boost/boost.zip
            popd
          fi

      - name: Create libsframe.so.2 compatibility symlink
        run: |
          # Check if .so.1 exists before creating the link
          if [ -f "/usr/lib/x86_64-linux-gnu/libsframe.so.1" ]; then
            echo "Creating compatibility link: libsframe.so.1 -> libsframe.so.2"
            sudo ln -sf /usr/lib/x86_64-linux-gnu/libsframe.so.1 /usr/lib/x86_64-linux-gnu/libsframe.so.2
          else
            echo "libsframe.so.1 not found. Cannot create compatibility link. Build may fail."
          fi

      - name: Cache the build
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Extract version from .jucer file
        # Try to derive version from a jucer file that is newer than the VERSION file, before configuring cmake
        # This step can be removed if/when the .jucer workflow is deprecated
        run: |
          echo "Version"
          while IFS= read -r -d $'\0' JUCER_FILE <&3; do
            if [ "$JUCER_FILE" -nt "VERSION" -a -n "`grep -h 'version=.\+Ctrlr' \"$JUCER_FILE\"`" ]; then
              grep -h 'version=.\+Ctrlr' "$JUCER_FILE" | sed -E 's/.*version="([^"]*).*/\1/g' | head -n 1 > VERSION
              echo "Found in $JUCER_FILE"
            fi
          done 3< <(find . -name "Ctrlr*.jucer" -type f -print0)
          cat VERSION
      
      - name: Configure
        run: >
          cmake -B ${{ env.BUILD_DIR }}
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE}}
          -DCMAKE_C_COMPILER_LAUNCHER=sccache
          -DCMAKE_CXX_COMPILER_LAUNCHER=sccache
          ${{ matrix.extra-flags }} .

      - name: Build
        run: cmake --build ${{ env.BUILD_DIR }} --config ${{ env.BUILD_TYPE }}
      # - name: Test & Benchmarks
      #   working-directory: ${{ env.BUILD_DIR }}
      #   run: ctest --verbose --output-on-failure

      - name: Read in .env from CMake # see GitHubENV.cmake
        run: |
          cat .env # show us the config
          cat .env >> $GITHUB_ENV # pull in our PRODUCT_NAME, etc

      - name: Set additional env vars for next steps
        run: |
          ARTIFACTS_PATH=${{ env.BUILD_DIR }}/${{ env.PROJECT_NAME }}_artefacts/${{ env.BUILD_TYPE }}
          echo "ARTIFACTS_PATH=$ARTIFACTS_PATH" >> $GITHUB_ENV
          echo "VST3_PATH=$ARTIFACTS_PATH/VST3/${{ env.PRODUCT_NAME }}.vst3" >> $GITHUB_ENV
          echo "AU_PATH=$ARTIFACTS_PATH/AU/${{ env.PRODUCT_NAME }}.component" >> $GITHUB_ENV
          echo "AUV3_PATH=$ARTIFACTS_PATH/AUv3/${{ env.PRODUCT_NAME }}.appex" >> $GITHUB_ENV
          echo "CLAP_PATH=$ARTIFACTS_PATH/CLAP/${{ env.PRODUCT_NAME }}.clap" >> $GITHUB_ENV
          echo "STANDALONE_PATH=$ARTIFACTS_PATH/Standalone/${{ env.PRODUCT_NAME }}.app" >> $GITHUB_ENV
          echo "ARTIFACT_NAME=${{ env.PRODUCT_NAME }}-${{ env.VERSION }}-${{ matrix.name }}" >> $GITHUB_ENV

      - name: Pluginval
        run: |
          curl -LO "https://github.com/Tracktion/pluginval/releases/download/v1.0.3/pluginval_${{ matrix.name }}.zip"
          7z x pluginval_${{ matrix.name }}.zip
          ${{ matrix.pluginval-binary }} --strictness-level 10 --verbose --validate "${{ env.VST3_PATH }}"

      - name: Check Final Binary Dependencies
        if: runner.os == 'Linux' && success()
        run: |
          echo "--- Checking dynamic libraries required by CtrlrX ---"
          # Assuming executable is ./build/CtrlrX
          ldd ./build/CtrlrX | grep libsframe
          ldd ./build/CtrlrX | grep NOT
          echo "----------------------------------------------------"
                    
      # -----------------------------------------------------------------
      # APPLE CODESIGNING STEPS
      # -----------------------------------------------------------------
      # Step 1: Import Merged Developer ID Certificates (This is confirmed working)
      - name: Import Merged Developer ID Certificates
        if: ${{ matrix.name == 'macOS' }}
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.DEV_ID_COMBO_CERT }}
          p12-password: ${{ secrets.DEV_ID_COMBO_PASSWORD }}
          keychain-password: gha_temp_password
          create-keychain: true 
          keychain: signing_temp

      # Step 2: Final Keychain Configuration (Bypass all trust anchor imports)
      - name: Final Keychain Configuration (Bypass Trust Anchor Import)
        if: ${{ matrix.name == 'macOS' }}
        run: |
          KEYCHAIN_NAME="signing_temp"
          KEYCHAIN_ABS_PATH="/Users/runner/Library/Keychains/${KEYCHAIN_NAME}.keychain-db"

          # CRITICAL STEP: Add the temporary keychain to the system's search list.
          /usr/bin/security list-keychains -d user -s "$KEYCHAIN_ABS_PATH" login.keychain

      # Step 3: Diagnostic and Codesign (The identity name is corrected here)
      - name: Codesign (macOS)
        if: ${{ matrix.name == 'macOS' }}
        run: |
          APP_IDENTITY="${{ secrets.DEVELOPER_ID_APPLICATION }}"

          echo "--- AVAILABLE SIGNING IDENTITIES ---"
          security find-identity -p codesigning -v
          echo "------------------------------------"
          echo "Attempting to sign with secret value: $APP_IDENTITY" # Diagnostic line

          # VST3
          codesign --force -s "$APP_IDENTITY" -v "${{ env.VST3_PATH }}" --deep --strict --options=runtime --timestamp
          # AU
          codesign --force -s "$APP_IDENTITY" -v "${{ env.AU_PATH }}" --deep --strict --options=runtime --timestamp
    
          # CLAP (Added file existence check to prevent previous failure)
          if [ -f "${{ env.CLAP_PATH }}" ]; then
            codesign --force -s "$APP_IDENTITY" -v "${{ env.CLAP_PATH }}" --deep --strict --options=runtime --timestamp
          else
            echo "Skipping CLAP codesign: ${{ env.CLAP_PATH }} not found."
          fi
    
          # Standalone
          codesign --force -s "$APP_IDENTITY" -v "${{ env.STANDALONE_PATH }}" --deep --strict --options=runtime --timestamp
    
      - name: Add Custom Icons (macOS)
        if: ${{ matrix.name == 'macOS' }}
        run: |
          # add the icns as its own icon resource (meta!)
          sips -i Packaging/Mac/Icon.icns

          # Grab the resource, put in tempfile
          DeRez -only icns Packaging/Mac/Icon.icns > /tmp/icons

          # Stuff the resource into the strange Icon? file's resource fork
          Rez -a /tmp/icons -o "${{ env.VST3_PATH }}/Icon"$'\r'
          Rez -a /tmp/icons -o "${{ env.AU_PATH }}/Icon"$'\r'
          # Rez -a /tmp/icons -o "${{ env.CLAP_PATH }}/Icon"$'\r'

          # Set custom icon attribute
          SetFile -a C "${{ env.VST3_PATH }}"
          SetFile -a C "${{ env.AU_PATH }}"
          # SetFile -a C "${{ env.CLAP_PATH }}"

      # -----------------------------------------------------------------
      # STEP 1: Signed Packaging and Notarization (Full Process)
      # -----------------------------------------------------------------
      - name: Signed Packaging and Notarization (macOS)
        if: ${{ matrix.name == 'macOS' && env.HAVE_DEV_ID_APP_CERT == 'true' && env.HAVE_DEV_ID_INSTALLER_CERT == 'true' }}
        timeout-minutes: 5
        run: |
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.au.pkg" --version $VERSION --component "${{ env.AU_PATH }}" --install-location "/Library/Audio/Plug-Ins/Components"  "Packaging/${{ env.PRODUCT_NAME }}.au.pkg"
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.vst3.pkg" --version $VERSION --component "${{ env.VST3_PATH }}" --install-location "/Library/Audio/Plug-Ins/VST3" "Packaging/${{ env.PRODUCT_NAME }}.vst3.pkg"
          # pkgbuild --identifier "${{ env.BUNDLE_ID }}.clap.pkg" --version $VERSION --component "${{ env.CLAP_PATH }}" --install-location "/Library/Audio/Plug-Ins/CLAP" "Packaging/${{ env.PRODUCT_NAME }}.clap.pkg"

          # Standalone is special, needs a boolean to always install in /Applications
          pkgbuild --analyze --root "$(dirname "${{ env.STANDALONE_PATH }}")" standalone.plist
          plutil -replace BundleIsRelocatable -bool NO standalone.plist
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.app.pkg" --version $VERSION --root "$(dirname "${{ env.STANDALONE_PATH }}")" --component-plist standalone.plist --install-location "/Applications" "Packaging/${{ env.PRODUCT_NAME }}.app.pkg"

          cd Packaging
          envsubst < ./Mac/distribution.xml.template > distribution.xml
          # SIGNED productbuild command
          productbuild --resources ./resources --distribution distribution.xml --sign "${{ secrets.DEVELOPER_ID_INSTALLER }}" --timestamp "${{ env.ARTIFACT_NAME }}.pkg"

          # Notarization and Stapling
          xcrun notarytool submit "${{ env.ARTIFACT_NAME }}.pkg" --apple-id ${{ secrets.NOTARIZATION_USERNAME }} --password ${{ secrets.NOTARIZATION_PASSWORD }} --team-id ${{ secrets.TEAM_ID }} --wait
          xcrun stapler staple "${{ env.ARTIFACT_NAME }}.pkg"

      # -----------------------------------------------------------------
      # STEP 2: Unsigned Packaging (Fallback)
      # -----------------------------------------------------------------
      - name: Unsigned Packaging (macOS)
        if: ${{ matrix.name == 'macOS' && (env.HAVE_DEV_ID_APP_CERT != 'true' || env.HAVE_DEV_ID_INSTALLER_CERT != 'true') }}
        timeout-minutes: 5
        run: |
          echo "WARNING: Codesigning secrets not found. Building unsigned package only."
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.au.pkg" --version $VERSION --component "${{ env.AU_PATH }}" --install-location "/Library/Audio/Plug-Ins/Components"  "Packaging/${{ env.PRODUCT_NAME }}.au.pkg"
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.vst3.pkg" --version $VERSION --component "${{ env.VST3_PATH }}" --install-location "/Library/Audio/Plug-Ins/VST3" "Packaging/${{ env.PRODUCT_NAME }}.vst3.pkg"
          # pkgbuild --identifier "${{ env.BUNDLE_ID }}.clap.pkg" --version $VERSION --component "${{ env.CLAP_PATH }}" --install-location "/Library/Audio/Plug-Ins/CLAP" "Packaging/${{ env.PRODUCT_NAME }}.clap.pkg"

          # Standalone is special, needs a boolean to always install in /Applications
          pkgbuild --analyze --root "$(dirname "${{ env.STANDALONE_PATH }}")" standalone.plist
          plutil -replace BundleIsRelocatable -bool NO standalone.plist
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.app.pkg" --version $VERSION --root "$(dirname "${{ env.STANDALONE_PATH }}")" --component-plist standalone.plist --install-location "/Applications" "Packaging/${{ env.PRODUCT_NAME }}.app.pkg"

          cd Packaging
          envsubst < ./Mac/distribution.xml.template > distribution.xml
          # UNSIGNED productbuild command (NO --sign or --timestamp)
          productbuild --resources ./resources --distribution distribution.xml "${{ env.ARTIFACT_NAME }}.pkg"

      # -----------------------------------------------------------------
      # LINUX GPG SIGNING
      # -----------------------------------------------------------------
      - name: Set up GnuPG and Import Key
        if: ${{ matrix.name == 'Linux' }}
        run: |
          # 1. Install GnuPG (if not already installed on ubuntu-24.04 runner)
          sudo apt-get update && sudo apt-get install -y gnupg
          # 2. Import the secret key from the GitHub secret
          echo "${{ secrets.GPG_SIGNING_KEY }}" | gpg --batch --import

      - name: Sign the Linux Binary
        if: ${{ matrix.name == 'Linux' }}
        # The target file is the Standalone executable, which is typically what you sign.
        # Based on your env setup, the Standalone binary is located at:
        # ${{ env.ARTIFACTS_PATH }}/Standalone/${{ env.PRODUCT_NAME }} (no extension on Linux)
        run: |
          BINARY_PATH="${{ env.ARTIFACTS_PATH }}/Standalone/${{ env.PRODUCT_NAME }}"
          SIGNATURE_PATH="${{ env.ARTIFACTS_PATH }}/Standalone/${{ env.PRODUCT_NAME }}.sig"

          echo "Attempting to sign binary at: $BINARY_PATH"

          # Use the GPG passphrase and key to create a detached signature (.sig file)
          gpg --batch --yes --pinentry-mode loopback \
              --passphrase "${{ secrets.GPG_SIGNING_PASSPHRASE }}" \
              --default-key "CtrlrX Project" \
              --output "$SIGNATURE_PATH" \
              --detach-sign "$BINARY_PATH"

          # Verification step (Optional but recommended)
          gpg --verify "$SIGNATURE_PATH" "$BINARY_PATH"
          echo "Signature created successfully at $SIGNATURE_PATH"

        env:
          GPG_PASSPHRASE: ${{ secrets.GPG_SIGNING_PASSPHRASE }}
                    
      - name: Zip (Linux)
        if: ${{ matrix.name == 'Linux' }}
        id: create_archive
        shell: bash
        run: |
          ARTIFACT_DIR="${{ env.ARTIFACTS_PATH }}/Standalone"

          # Define the internal folder name for the user's extraction
          INTERNAL_FOLDER_NAME="${{ env.ARTIFACT_NAME }}-Signed"
          
          # Define the final output file name on the runner (use the simple, absolute path)
          FINAL_ZIP_NAME="${{ env.ARTIFACT_NAME }}.zip"
          ABSOLUTE_ZIP_PATH="${{ github.workspace }}/$FINAL_ZIP_NAME"

          # 1. Create a temporary staging folder and the internal target folder
          mkdir -p "tmp_linux_archive/$INTERNAL_FOLDER_NAME"

          # 2. Copy final assets into the INTERNAL folder
          cp "${ARTIFACT_DIR}/${{ env.PRODUCT_NAME }}" "tmp_linux_archive/$INTERNAL_FOLDER_NAME/"
          cp "${ARTIFACT_DIR}/${{ env.PRODUCT_NAME }}.sig" "tmp_linux_archive/$INTERNAL_FOLDER_NAME/"
          cp -r "build/CtrlrX_artefacts/Release/VST3/CtrlrX.vst3" "tmp_linux_archive/$INTERNAL_FOLDER_NAME/"

          # 3. Change into the temporary staging directory (which contains ONE subfolder)
          cd tmp_linux_archive

          # 4. Create the final ZIP archive. 
          # Zipping '*' from here includes the single subfolder and its contents.
          zip -r "$ABSOLUTE_ZIP_PATH" *    

          # Set output (harmless)
          echo "ARCHIVE_PATH=$FINAL_ZIP_NAME" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------
      # WINDOWS AZURE CODESIGNING STEP 1 (STANDALONE .EXE & .VST3)
      # -----------------------------------------------------------------
      
      - name: Codesign with Azure Trusted Signing (Windows Plugins .EXE & .VST3)
        if: ${{ matrix.name == 'Windows' && env.HAVE_AZURE_CLIENT_SECRET == 'true' }}
        uses: azure/trusted-signing-action@v0.5.1
        with:
        
          # NOTE : Your Azure Trusted Signing Account also requires the "Trusted Signing Certificate Profile Signer" role.

          # The Azure Active Directory tenant (directory) ID.
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}

          # The client (application) ID of an App Registration in the tenant.
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}

          # A client secret that was generated for the App Registration.
          azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

          # The Code Signing Account endpoint. The URI value must have a URI that aligns to the region your Code Signing Account and Certificate Profile you are specifying were created in during the setup of these resources.
          endpoint: ${{ secrets.AZURE_ENDPOINT }}

          # The Code Signing Account name.
          trusted-signing-account-name: ${{ secrets.AZURE_CODE_SIGNING_NAME }}

          # The Certificate Profile name.
          certificate-profile-name: ${{ secrets.AZURE_CERT_PROFILE_NAME }}

          # This signs all exes inside the folder
          files-folder: ${{ env.ARTIFACTS_PATH }}

          # Filter for the required file type
          files-folder-filter: exe,dll,vst3

          # Enable recursive search (The correct parameter)
          files-folder-recurse: true

      # -----------------------------------------------------------------
      # WINDOWS INSTALL .EXE
      # -----------------------------------------------------------------

      - name: Generate Installer (Windows)
        if: ${{ matrix.name == 'Windows' }}
        run: |
          iscc "Packaging\Windows\installer.iss"
          find -iname "*.exe"
          mv "Packaging/Windows/Output/${{ env.ARTIFACT_NAME }}.exe" "${{ env.ARTIFACTS_PATH }}/"

      # -----------------------------------------------------------------
      # WINDOWS AZURE CODESIGNING STEP 2 (INSTALL .EXE)
      # -----------------------------------------------------------------
      
      - name: Codesign with Azure Trusted Signing (Windows Installer)
        if: ${{ matrix.name == 'Windows' && env.HAVE_AZURE_CLIENT_SECRET == 'true' }}
        uses: azure/trusted-signing-action@v0.5.1
        with:
        
          # NOTE : Your Azure Trusted Signing Account also requires the "Trusted Signing Certificate Profile Signer" role.

          # The Azure Active Directory tenant (directory) ID.
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}

          # The client (application) ID of an App Registration in the tenant.
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}

          # A client secret that was generated for the App Registration.
          azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

          # The Code Signing Account endpoint. The URI value must have a URI that aligns to the region your Code Signing Account and Certificate Profile you are specifying were created in during the setup of these resources.
          endpoint: ${{ secrets.AZURE_ENDPOINT }}

          # The Code Signing Account name.
          trusted-signing-account-name: ${{ secrets.AZURE_CODE_SIGNING_NAME }}

          # The Certificate Profile name.
          certificate-profile-name: ${{ secrets.AZURE_CERT_PROFILE_NAME }}

          # Target: ONLY the final installer EXE
          files-folder: ${{ env.ARTIFACTS_PATH }}
          files-folder-filter: "${{ env.ARTIFACT_NAME }}.exe"
          files-folder-recurse: false # Do not recurse, just look in the main folder

      # -----------------------------------------------------------------
      # UPLOAD ARTEFACTS
      # -----------------------------------------------------------------

      - name: Upload Exe (Windows)
        if: ${{ matrix.name == 'Windows' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}.exe
          path: "${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.exe"

      - name: Upload Zip (Linux)
        if: ${{ matrix.name == 'Linux' }}
        uses: actions/upload-artifact@v4
        with:
          # Use ARTIFACT_NAME only. GitHub will append .zip to the download name.
          name: ${{ env.ARTIFACT_NAME }}
          path: |
            # Point to the file we created on the runner
            ${{ github.workspace }}/${{ env.ARTIFACT_NAME }}.zip

      - name: Upload pkg (macOS)
        if: ${{ matrix.name == 'macOS' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}.pkg
          path: Packaging/${{ env.ARTIFACT_NAME }}.pkg

      # Enable tmate debugging of manually-triggered workflows if the input option was provided
      - name: Setup tmate session if failed
        uses: mxschmitt/action-tmate@v3
        if: ${{ failure() && (github.event_name == 'workflow_dispatch' && inputs.debug_enabled) || (runner.debug) }}


  release:
    if: contains(github.ref, 'tags/v')
    runs-on: ubuntu-latest
    needs: build_and_test

    steps:
      - name: Get Readme
        uses: actions/checkout@v4
        # (sparse) checkout needs to happen before getting artifacts, as it will 'clean' the directory.
        with:
          sparse-checkout: |
            README.md
            VERSION
          sparse-checkout-cone-mode: false

      - name: Get Artifacts
        uses: actions/download-artifact@v4
  
      - name: Compose release notes
        # Extract the first sub section after '## Changelog' until the next subsection from the README
        run: |
          set +e  # ignore failures
          echo '![alt text](/Source/Resources/Icons/CtrlrX-README-250x315.png?raw=true "CtrlrX")' > release_notes.txt
          echo -e "\n# CtrlrX ${GITHUB_REF_NAME} - Changelog" >> release_notes.txt
          sed '0,/^## Changelog/d; 0,/^##/d; /##/,$d' README.md >> release_notes.txt
          cat release_notes.txt

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          body_path: release_notes.txt
          prerelease: true
          # download-artifact puts these files in their own dirs...
          # Using globs sidesteps having to pass the version around
          files: |
            */*.exe
            **/*/*.zip
            */*.pkg
            **/*Standalone/*.sig
