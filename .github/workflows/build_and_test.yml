name: Pamplejuce

on:
  workflow_dispatch: # lets you run a build from the UI
    inputs:
      debug_enabled:
        type: boolean
        description: 'Run the build with tmate debugging enabled (https://github.com/marketplace/actions/debugging-with-tmate)'
        required: false
        default: false
  push:
  pull_request:

# When pushing new commits, cancel any running builds on that branch
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

env:
  BUILD_TYPE: Release
  BUILD_DIR: build
  DISPLAY: :0 # linux pluginval needs this
  HOMEBREW_NO_INSTALL_CLEANUP: 1
  SCCACHE_GHA_ENABLED: true
  SCCACHE_CACHE_MULTIARCH: 1
  IPP_DIR: C:\Program Files (x86)\Intel\oneAPI\ipp\latest\lib\cmake\ipp

defaults:
  run:
    shell: bash

# -----------------------------------------------------------------
 # START OF ALL JOBS ON DIFFERENT MACHINES
# -----------------------------------------------------------------
# jobs are run in parallel on different machines
# all steps run in series
jobs:
  build_and_test:
    # don't double run on PRs
    if: github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name != github.event.pull_request.base.repo.full_name
    name: ${{ matrix.name }}
    runs-on: ${{ matrix.os }}
    env:
      HAVE_DEV_ID_APP_CERT: ${{ secrets.DEV_ID_APP_CERT != '' }}
      HAVE_DEV_ID_INSTALLER_CERT: ${{ secrets.DEV_ID_INSTALLER_CERT != '' }}
      HAVE_AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET != '' }}
    strategy:
      fail-fast: false # show all errors for each platform (vs. cancel jobs on error)
      matrix:
        include:
          - name: Linux
            os: ubuntu-24.04
            pluginval-binary: ./pluginval
            # FIX: Explicitly define JUCE_LINUX for the build to enable conditional BFD includes in libr.h/c
            extra-flags: -G Ninja -DJUCE_LINUX=1
          - name: macOS
            os: macos-14
            pluginval-binary: pluginval.app/Contents/MacOS/pluginval
            extra-flags: -G Ninja -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          - name: Windows
            os: windows-2022
            pluginval-binary: ./pluginval.exe

    steps:
      # Setup MSVC toolchain and developer command prompt (Windows)
      - uses: ilammy/msvc-dev-cmd@v1

      # Use clang on Linux so we don't introduce a 3rd compiler (Windows and macOS use MSVC and Clang)
      - name: Set up Clang
        if: runner.os == 'Linux'
        uses: egor-tensin/setup-clang@v1

      # This also starts up our "fake" display (Xvfb), needed for pluginval
      - name: Install JUCE's Linux Deps
        if: runner.os == 'Linux'
        # Thanks to McMartin & co https://forum.juce.com/t/list-of-juce-dependencies-under-linux/15121/44
        run: |
          sudo apt-get update && sudo apt install libasound2-dev libx11-dev libxinerama-dev libxext-dev libfreetype6-dev libglu1-mesa-dev xvfb ninja-build
          sudo /usr/bin/Xvfb $DISPLAY &

      - name: Install IPP (Windows)
        if: (runner.os == 'Windows')
        run: |
          nuget install intelipp.static.win-x64 -Version 2022.2.0.575

      - name: Install Ninja (Windows)
        if: runner.os == 'Windows'
        run: choco install ninja

      - name: Install macOS Deps
        if: ${{ matrix.name == 'macOS' }}
        run: brew install osxutils

      # This block can be removed once 15.1 is default (JUCE requires it when building on macOS 14)
      - name: Use latest Xcode on system (macOS)
        if: ${{ matrix.name == 'macOS' }}
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install CtrlrX Deps
        run: |
          echo "OS: $RUNNER_OS"
          echo "Current working directory: $PWD"
          if [ "$RUNNER_OS" == "Linux" ]; then
            sudo apt install -y binutils-dev libboost-dev libcurl4-gnutls-dev libgl1-mesa-dev libglapi-mesa libiberty-dev libsframe1 libudev-dev libxcursor-dev libxrandr-dev xorg-dev
          elif [ "$RUNNER_OS" == "Windows" ]; then
            # to not clutter the build step logs:
            pushd ./Source/Misc/
            unzip boost/boost.zip
            popd
          elif [ "$RUNNER_OS" == "macOS" ]; then
            brew install boost
            # somehow cmake doesn't pick up on /usr/local/include/boost/ ... maybe have to set it in the .jucer project
            pushd ./Source/Misc/
            unzip boost/boost.zip
            popd
          fi

      - name: Cache the build
        uses: mozilla-actions/sccache-action@v0.0.9

      - name: Extract version from .jucer file
        # Try to derive version from a jucer file that is newer than the VERSION file, before configuring cmake
        # This step can be removed if/when the .jucer workflow is deprecated
        run: |
          echo "Version"
          while IFS= read -r -d $'\0' JUCER_FILE <&3; do
            if [ "$JUCER_FILE" -nt "VERSION" -a -n "`grep -h 'version=.\+Ctrlr' \"$JUCER_FILE\"`" ]; then
              grep -h 'version=.\+Ctrlr' "$JUCER_FILE" | sed -E 's/.*version="([^"]*).*/\1/g' | head -n 1 > VERSION
              echo "Found in $JUCER_FILE"
            fi
          done 3< <(find . -name "Ctrlr*.jucer" -type f -print0)
          cat VERSION
      
      - name: Configure
        run: >
          cmake -B ${{ env.BUILD_DIR }}
          -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE}}
          -DCMAKE_C_COMPILER_LAUNCHER=sccache
          -DCMAKE_CXX_COMPILER_LAUNCHER=sccache
          ${{ matrix.extra-flags }} .

      - name: Build
        run: cmake --build ${{ env.BUILD_DIR }} --config ${{ env.BUILD_TYPE }}
      # - name: Test & Benchmarks
      #   working-directory: ${{ env.BUILD_DIR }}
      #   run: ctest --verbose --output-on-failure

      - name: Read in .env from CMake # see GitHubENV.cmake
        run: |
          cat .env # show us the config
          cat .env >> $GITHUB_ENV # pull in our PRODUCT_NAME, etc

      - name: Set additional env vars for next steps
        run: |
          ARTIFACTS_PATH=${{ env.BUILD_DIR }}/${{ env.PROJECT_NAME }}_artefacts/${{ env.BUILD_TYPE }}
          echo "ARTIFACTS_PATH=$ARTIFACTS_PATH" >> $GITHUB_ENV
          echo "VST3_PATH=$ARTIFACTS_PATH/VST3/${{ env.PRODUCT_NAME }}.vst3" >> $GITHUB_ENV
          echo "AU_PATH=$ARTIFACTS_PATH/AU/${{ env.PRODUCT_NAME }}.component" >> $GITHUB_ENV
          echo "AUV3_PATH=$ARTIFACTS_PATH/AUv3/${{ env.PRODUCT_NAME }}.appex" >> $GITHUB_ENV
          echo "CLAP_PATH=$ARTIFACTS_PATH/CLAP/${{ env.PRODUCT_NAME }}.clap" >> $GITHUB_ENV
          echo "STANDALONE_PATH=$ARTIFACTS_PATH/Standalone/${{ env.PRODUCT_NAME }}.app" >> $GITHUB_ENV
          echo "ARTIFACT_NAME=${{ env.PRODUCT_NAME }}-${{ env.VERSION }}-${{ matrix.name }}" >> $GITHUB_ENV

      # -----------------------------------------------------------------
      # PLUGINVAL TEST
      # -----------------------------------------------------------------
      # Step 1: Run the pluginval tool
      - name: Pluginval
        id: pluginval
        run: |
          curl -LO "https://github.com/Tracktion/pluginval/releases/download/v1.0.3/pluginval_${{ matrix.name }}.zip"
          7z x pluginval_${{ matrix.name }}.zip
          ${{ matrix.pluginval-binary }} --strictness-level 10 --verbose --validate "${{ env.VST3_PATH }}"

      # Step 2: Track pluginval status
      - name: Track Pluginval Status
        if: always()
        run: |
          # Check the status of the PREVIOUS step: 'Pluginval'
          if [ "${{ steps.pluginval.outcome }}" == "success" ]; then
            echo "PLUGINVAL_STATUS=success" >> $GITHUB_ENV
          else
            echo "PLUGINVAL_STATUS=failure" >> $GITHUB_ENV
          fi

      # -----------------------------------------------------------------
      # APPLE CODESIGNING STEPS
      # -----------------------------------------------------------------
      # Step 1: Import Merged Developer ID Certificates
      - name: Import Merged Developer ID Certificates
        if: ${{ matrix.name == 'macOS' }}
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.DEV_ID_COMBO_CERT }}
          p12-password: ${{ secrets.DEV_ID_COMBO_PASSWORD }}
          keychain-password: gha_temp_password
          create-keychain: true 
          keychain: signing_temp

      # Step 2: Final Keychain Configuration
      - name: Final Keychain Configuration
        if: ${{ matrix.name == 'macOS' }}
        run: |
          KEYCHAIN_NAME="signing_temp"
          KEYCHAIN_ABS_PATH="/Users/runner/Library/Keychains/${KEYCHAIN_NAME}.keychain-db"

          # CRITICAL STEP: Add the temporary keychain to the system's search list.
          /usr/bin/security list-keychains -d user -s "$KEYCHAIN_ABS_PATH" login.keychain

      # Step 3: Diagnostic and Codesign (The identity name is corrected here)
      - name: Codesign (macOS)
        id: macos-codesign
        if: ${{ matrix.name == 'macOS' }}
        run: |
          APP_IDENTITY="${{ secrets.DEVELOPER_ID_APPLICATION }}"

          echo "--- AVAILABLE SIGNING IDENTITIES ---"
          security find-identity -p codesigning -v
          echo "------------------------------------"
          echo "Attempting to sign with secret value: $APP_IDENTITY" # Diagnostic line

          # VST3
          codesign --force -s "$APP_IDENTITY" -v "${{ env.VST3_PATH }}" --deep --strict --options=runtime --timestamp
          # AU
          codesign --force -s "$APP_IDENTITY" -v "${{ env.AU_PATH }}" --deep --strict --options=runtime --timestamp

          # CLAP (Added file existence check to prevent previous failure)
          if [ -f "${{ env.CLAP_PATH }}" ]; then
            codesign --force -s "$APP_IDENTITY" -v "${{ env.CLAP_PATH }}" --deep --strict --options=runtime --timestamp
          else
            echo "Skipping CLAP codesign: ${{ env.CLAP_PATH }} not found."
          fi

          # Standalone
          codesign --force -s "$APP_IDENTITY" -v "${{ env.STANDALONE_PATH }}" --deep --strict --options=runtime --timestamp

      # Step 4: Track macOS Codesigning Status
      - name: Track macOS Codesigning Status
        if: ${{ always() && matrix.name == 'macOS' }}
        run: |
          if [ "${{ steps.macos-codesign.outcome }}" == "success" ]; then
            echo "MACOS_SIGNING_STATUS=success" >> $GITHUB_ENV
          else
            echo "MACOS_SIGNING_STATUS=failure" >> $GITHUB_ENV
          fi

      # -----------------------------------------------------------------
      # APPLE ADDING CUSTOM ICONS
      # -----------------------------------------------------------------
                    
      - name: Add Custom Icons (macOS)
        if: ${{ matrix.name == 'macOS' }}
        run: |
          # add the icns as its own icon resource (meta!)
          sips -i Packaging/Mac/Icon.icns

          # Grab the resource, put in tempfile
          DeRez -only icns Packaging/Mac/Icon.icns > /tmp/icons

          # Stuff the resource into the strange Icon? file's resource fork
          Rez -a /tmp/icons -o "${{ env.VST3_PATH }}/Icon"$'\r'
          Rez -a /tmp/icons -o "${{ env.AU_PATH }}/Icon"$'\r'
          # Rez -a /tmp/icons -o "${{ env.CLAP_PATH }}/Icon"$'\r'

          # Set custom icon attribute
          SetFile -a C "${{ env.VST3_PATH }}"
          SetFile -a C "${{ env.AU_PATH }}"
          # SetFile -a C "${{ env.CLAP_PATH }}"

      # -----------------------------------------------------------------
      # NEW STEP 1: Signed Packaging and Notarization (Full Process)
      # -----------------------------------------------------------------
      - name: Signed Packaging and Notarization (macOS)
        id: signed-packaging-and-notarization
        if: ${{ matrix.name == 'macOS' && env.HAVE_DEV_ID_APP_CERT == 'true' && env.HAVE_DEV_ID_INSTALLER_CERT == 'true' }}
        timeout-minutes: 5
        run: |
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.au.pkg" --version $VERSION --component "${{ env.AU_PATH }}" --install-location "/Library/Audio/Plug-Ins/Components"  "Packaging/${{ env.PRODUCT_NAME }}.au.pkg"
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.vst3.pkg" --version $VERSION --component "${{ env.VST3_PATH }}" --install-location "/Library/Audio/Plug-Ins/VST3" "Packaging/${{ env.PRODUCT_NAME }}.vst3.pkg"
          # pkgbuild --identifier "${{ env.BUNDLE_ID }}.clap.pkg" --version $VERSION --component "${{ env.CLAP_PATH }}" --install-location "/Library/Audio/Plug-Ins/CLAP" "Packaging/${{ env.PRODUCT_NAME }}.clap.pkg"

          # Standalone is special, needs a boolean to always install in /Applications
          pkgbuild --analyze --root "$(dirname "${{ env.STANDALONE_PATH }}")" standalone.plist
          plutil -replace BundleIsRelocatable -bool NO standalone.plist
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.app.pkg" --version $VERSION --root "$(dirname "${{ env.STANDALONE_PATH }}")" --component-plist standalone.plist --install-location "/Applications" "Packaging/${{ env.PRODUCT_NAME }}.app.pkg"

          cd Packaging
          envsubst < ./Mac/distribution.xml.template > distribution.xml
          # SIGNED productbuild command
          productbuild --resources ./resources --distribution distribution.xml --sign "${{ secrets.DEVELOPER_ID_INSTALLER }}" --timestamp "${{ env.ARTIFACT_NAME }}.pkg"

          # Notarization and Stapling
          xcrun notarytool submit "${{ env.ARTIFACT_NAME }}.pkg" --apple-id ${{ secrets.NOTARIZATION_USERNAME }} --password ${{ secrets.NOTARIZATION_PASSWORD }} --team-id ${{ secrets.TEAM_ID }} --wait
          xcrun stapler staple "${{ env.ARTIFACT_NAME }}.pkg"
          
      # Step 5: Track macOS Notarization Status
      - name: Track macOS Notarization Status
        if: ${{ always() && matrix.name == 'macOS' }}
        run: |
          # The 'Signed Packaging and Notarization (macOS)' step contains the notarization
          # If that step succeeded, we assume notarization and stapling succeeded.
          if [ "${{ steps.signed-packaging-and-notarization.outcome }}" == "success" ]; then
            echo "MACOS_NOTARIZED_STATUS=success" >> $GITHUB_ENV
          else
            echo "MACOS_NOTARIZED_STATUS=failure" >> $GITHUB_ENV
          fi

      # -----------------------------------------------------------------
      # NEW STEP 2: Unsigned Packaging (Fallback)
      # -----------------------------------------------------------------
      - name: Unsigned Packaging (macOS)
        if: ${{ matrix.name == 'macOS' && (env.HAVE_DEV_ID_APP_CERT != 'true' || env.HAVE_DEV_ID_INSTALLER_CERT != 'true') }}
        timeout-minutes: 5
        run: |
          echo "WARNING: Codesigning secrets not found. Building unsigned package only."
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.au.pkg" --version $VERSION --component "${{ env.AU_PATH }}" --install-location "/Library/Audio/Plug-Ins/Components"  "Packaging/${{ env.PRODUCT_NAME }}.au.pkg"
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.vst3.pkg" --version $VERSION --component "${{ env.VST3_PATH }}" --install-location "/Library/Audio/Plug-Ins/VST3" "Packaging/${{ env.PRODUCT_NAME }}.vst3.pkg"
          # pkgbuild --identifier "${{ env.BUNDLE_ID }}.clap.pkg" --version $VERSION --component "${{ env.CLAP_PATH }}" --install-location "/Library/Audio/Plug-Ins/CLAP" "Packaging/${{ env.PRODUCT_NAME }}.clap.pkg"

          # Standalone is special, needs a boolean to always install in /Applications
          pkgbuild --analyze --root "$(dirname "${{ env.STANDALONE_PATH }}")" standalone.plist
          plutil -replace BundleIsRelocatable -bool NO standalone.plist
          pkgbuild --identifier "${{ env.BUNDLE_ID }}.app.pkg" --version $VERSION --root "$(dirname "${{ env.STANDALONE_PATH }}")" --component-plist standalone.plist --install-location "/Applications" "Packaging/${{ env.PRODUCT_NAME }}.app.pkg"

          cd Packaging
          envsubst < ./Mac/distribution.xml.template > distribution.xml
          # UNSIGNED productbuild command (NO --sign or --timestamp)
          productbuild --resources ./resources --distribution distribution.xml "${{ env.ARTIFACT_NAME }}.pkg"

      - name: Zip (Linux)
        if: ${{ matrix.name == 'Linux' }}
        working-directory: ${{ env.ARTIFACTS_PATH }}
        run: 7z a -tzip "${{ env.ARTIFACT_NAME }}.zip" "-xr!lib${{ env.PRODUCT_NAME }}_SharedCode.a" .

      - name: Generate Installer (Windows)
        if: ${{ matrix.name == 'Windows' }}
        run: |
          iscc "Packaging\Windows\installer.iss"
          find -iname "*.exe"
          mv "Packaging/Windows/Output/${{ env.ARTIFACT_NAME }}.exe" "${{ env.ARTIFACTS_PATH }}/"

      # -----------------------------------------------------------------
      # AZURE CODESIGNING STEP
      # -----------------------------------------------------------------
      # Step 1: Codesign with Azure Trusted Signing
      - name: Codesign with Azure Trusted Signing (Windows)
        if: ${{ matrix.name == 'Windows' && env.HAVE_AZURE_CLIENT_SECRET == 'true' }}
        uses: azure/trusted-signing-action@v0.5.1
        with:
          # The Azure Active Directory tenant (directory) ID.
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}

          # The client (application) ID of an App Registration in the tenant.
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}

          # A client secret that was generated for the App Registration.
          azure-client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

          # The Code Signing Account endpoint. The URI value must have a URI that aligns to the region your Code Signing Account and Certificate Profile you are specifying were created in during the setup of these resources.
          endpoint: ${{ secrets.AZURE_ENDPOINT }}

          # The Code Signing Account name.
          trusted-signing-account-name: ${{ secrets.AZURE_CODE_SIGNING_NAME }}

          # The Certificate Profile name.
          certificate-profile-name: ${{ secrets.AZURE_CERT_PROFILE_NAME }}

          # This signs all exes inside the folder
          files-folder: ${{ env.ARTIFACTS_PATH }}
          files-folder-filter: exe

      # Step 2: Track Azure Signing Status
      - name: Track Azure Signing Status
        if: ${{ always() && matrix.name == 'Windows' }}
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "AZURE_SIGNING_STATUS=success" >> $GITHUB_ENV
          else
            echo "AZURE_SIGNING_STATUS=failure" >> $GITHUB_ENV
          fi
          
      - name: Upload Exe (Windows)
        if: ${{ matrix.name == 'Windows' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}.exe
          path: "${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.exe"

      - name: Upload Zip (Linux)
        if: ${{ matrix.name == 'Linux' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}.zip
          path: "${{ env.ARTIFACTS_PATH }}/${{ env.ARTIFACT_NAME }}.zip"

      - name: Upload pkg (macOS)
        if: ${{ matrix.name == 'macOS' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ARTIFACT_NAME }}.pkg
          path: Packaging/${{ env.ARTIFACT_NAME }}.pkg

      # Enable tmate debugging of manually-triggered workflows if the input option was provided
      - name: Setup tmate session if failed
        uses: mxschmitt/action-tmate@v3
        if: ${{ failure() && (github.event_name == 'workflow_dispatch' && inputs.debug_enabled) || (runner.debug) }}

      # -----------------------------------------------------------------
      # CREATE STATUS ARTIFACT
      # -----------------------------------------------------------------
      - name: Create Status Artifact
        run: |
          # Use job.status to capture the overall job result
          echo "BUILD_STATUS_${{ matrix.name }}=${{ job.status }}" > build_status.txt
          echo "PLUGINVAL_STATUS=${{ env.PLUGINVAL_STATUS }}" >> build_status.txt

          # --- macOS ONLY STATUSES ---
          if [ "${{ matrix.name }}" == "macOS" ]; then
            echo "MACOS_SIGNING_STATUS=${{ env.MACOS_SIGNING_STATUS }}" >> build_status.txt
            echo "MACOS_NOTARIZED_STATUS=${{ env.MACOS_NOTARIZED_STATUS }}" >> build_status.txt
          fi

          # --- Windows ONLY STATUSES ---
          if [ "${{ matrix.name }}" == "Windows" ]; then
            echo "AZURE_SIGNING_STATUS=${{ env.AZURE_SIGNING_STATUS }}" >> build_status.txt
          fi
          cat build_status.txt

      - name: Upload Status Artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-statuses-${{ matrix.name }}
          path: build_status.txt

      # -----------------------------------------------------------------
      # END OF ALL MATRIX-SPECIFIC BUILD AND TEST STEPS
      # START OF ALL README FILE UPDATE WITH BADGES STEPS
      # -----------------------------------------------------------------

  update_readme_badges:
    runs-on: ubuntu-latest
    needs: build_and_test

    steps:
      - name: Get Readme and VERSION content
        uses: actions/checkout@v4
        # (sparse) checkout needs to happen before getting artifacts, as it will 'clean' the directory.
        with:
          sparse-checkout: |
            README.md
            VERSION
          sparse-checkout-cone-mode: false
          
      - name: Read VERSION into Environment
        id: read_version
        run: |
          # Reads the content of the VERSION file and sets it as an environment variable
          VERSION_NUMBER=$(cat VERSION | tr -d '\n')
          echo "VERSION=$VERSION_NUMBER" >> $GITHUB_ENV
          echo "Set VERSION to: $VERSION_NUMBER"
          
      - name: Get Artifacts
        uses: actions/download-artifact@v4
        with:
          path: build-statuses/ # This directory will now contain three subdirectories
 
      - name: Set Badge Statuses from Artifact
        id: set_statuses
        run: |
          find build-statuses/ -name "build_status.txt" -print0 | while IFS= read -r -d $'\0' status_file; do
            PLATFORM=$(basename "$(dirname "$status_file")" | sed 's/build-statuses-//')
            echo "Processing status for $PLATFORM"

            # Load all variables from the artifact file into memory
            source "$status_file"

            # Now map the specific variables to the required format for the badge function
            if [ "$PLATFORM" == "macOS" ]; then
              echo "PLATFORM_macOS_PLUGINVAL_STATUS=$PLUGINVAL_STATUS" >> $GITHUB_ENV
              # Only map macOS signing/notarization for macOS platform
              echo "PLATFORM_macOS_CODESIGN_STATUS=$MACOS_SIGNING_STATUS" >> $GITHUB_ENV
              echo "PLATFORM_macOS_NOTARIZED_STATUS=$MACOS_NOTARIZED_STATUS" >> $GITHUB_ENV
            elif [ "$PLATFORM" == "Windows" ]; then
              echo "PLATFORM_Windows_PLUGINVAL_STATUS=$PLUGINVAL_STATUS" >> $GITHUB_ENV
              # Only map Azure signing for Windows platform
              echo "PLATFORM_Windows_CODESIGN_STATUS=$AZURE_SIGNING_STATUS" >> $GITHUB_ENV
            elif [ "$PLATFORM" == "Linux" ]; then
              echo "PLATFORM_Linux_PLUGINVAL_STATUS=$PLUGINVAL_STATUS" >> $GITHUB_ENV
            fi
          done

      - name: Generate Shields.io Badges
        run: |
          # Function to generate badge markdown for tracked statuses
          generate_tracked_badge() {
            local platform_label=$1 # e.g., macOS
            local sub_label=$2 # e.g., Codesign
            local env_var=$3
            local status="${!env_var}"
            local color="inactive"
            # Use the full, readable label for the display: "macOS Pluginval"
            local full_label="${platform_label} ${sub_label}" 
             # URL-encoded label: "macOS%20Pluginval"
            local url_label=$(echo "$full_label" | sed 's/ /%20/g') 
            local message="N%2FA" # Default to N/A

            if [ "$status" == "success" ]; then
              color="brightgreen"
              message="PASSED"
            elif [ "$status" == "failure" ]; then
              color="red"
              message="FAILED"
            fi
             # Fixes the missing label in the badge URL
            echo "[![${full_label} Status](https://img.shields.io/badge/${url_label}-${message}-${color}?style=flat&logo=github)]()"
          }

          # --- 1. CONSOLIDATE AND FORMAT ALL DYNAMIC BADGES INTO A FILE ---
          ALL_BADGE_CONTENT_FILE="all_badges_content.txt"

          # COMMON BADGES (Last Updated)
          LAST_UPDATED_DATE=$(date +"%Y--%m--%d")
          echo "[![Last Updated](https://img.shields.io/badge/Last%20Updated-${LAST_UPDATED_DATE}-blue?style=flat)]()" > "$ALL_BADGE_CONTENT_FILE"
          echo "" >> "$ALL_BADGE_CONTENT_FILE"
          echo "### Build and Validation Status" >> "$ALL_BADGE_CONTENT_FILE"
          echo "" >> "$ALL_BADGE_CONTENT_FILE"

          # MACOS BADGES
          MACOS_BUILD_BADGE='[![macOS Build](https://github.com/damiensellier/CtrlrX/actions/workflows/build_and_test.yml/badge.svg?branch=${{ github.ref_name }}&job=macOS)](https://github.com/damiensellier/CtrlrX/actions/workflows/build_and_test.yml)'
             # Updated to use 'Apple Codesign' as the sub-label
          MACOS_CODESIGN_BADGE=$(generate_tracked_badge "macOS" "Apple Codesign" "PLATFORM_macOS_CODESIGN_STATUS")
             # Updated to use 'Notarized' as the sub-label
          MACOS_NOTARIZED_BADGE=$(generate_tracked_badge "macOS" "Notarized" "PLATFORM_macOS_NOTARIZED_STATUS")
             # Updated to use 'Pluginval' as the sub-label
          MACOS_PLUGINVAL_BADGE=$(generate_tracked_badge "macOS" "Pluginval" "PLATFORM_macOS_PLUGINVAL_STATUS")
             # Added a newline after the macOS badge group
          echo "$MACOS_BUILD_BADGE $MACOS_CODESIGN_BADGE $MACOS_NOTARIZED_BADGE $MACOS_PLUGINVAL_BADGE" >> "$ALL_BADGE_CONTENT_FILE"
          echo "" >> "$ALL_BADGE_CONTENT_FILE" 

          # WINDOWS BADGES
          WINDOWS_BUILD_BADGE='[![Windows Build](https://github.com/damiensellier/CtrlrX/actions/workflows/build_and_test.yml/badge.svg?branch=${{ github.ref_name }}&job=Windows)](https://github.com/damiensellier/CtrlrX/actions/workflows/build_and_test.yml)'
             # Updated to use 'Azure Codesign' as the sub-label
          WINDOWS_CODESIGN_BADGE=$(generate_tracked_badge "Windows" "Azure Codesign" "PLATFORM_Windows_CODESIGN_STATUS")
             # Updated to use 'Pluginval' as the sub-label
          WINDOWS_PLUGINVAL_BADGE=$(generate_tracked_badge "Windows" "Pluginval" "PLATFORM_Windows_PLUGINVAL_STATUS")
             # Added a newline after the Windows badge group
          echo "$WINDOWS_BUILD_BADGE $WINDOWS_CODESIGN_BADGE $WINDOWS_PLUGINVAL_BADGE" >> "$ALL_BADGE_CONTENT_FILE"
          echo "" >> "$ALL_BADGE_CONTENT_FILE" 

          # LINUX BADGES
          LINUX_BUILD_BADGE='[![Linux Build](https://github.com/damiensellier/CtrlrX/actions/workflows/build_and_test.yml/badge.svg?branch=${{ github.ref_name }}&job=Linux)](https://github.com/damiensellier/CtrlrX/actions/workflows/build_and_test.yml)'
             # Updated to use 'Pluginval' as the sub-label
          LINUX_PLUGINVAL_BADGE=$(generate_tracked_badge "Linux" "Pluginval" "PLATFORM_Linux_PLUGINVAL_STATUS")
          echo "$LINUX_BUILD_BADGE $LINUX_PLUGINVAL_BADGE" >> "$ALL_BADGE_CONTENT_FILE"

          echo "**" >> "$ALL_BADGE_CONTENT_FILE"
          
          # Print for diagnostic
          cat "$ALL_BADGE_CONTENT_FILE"

      - name: Insert Badges into README.md
        run: |
          # The multi-line badge content is in 'all_badges_content.txt'

          # 1. Define the start and end markers
          START_MARKER='**'
          END_MARKER='## Table of Contents' # Use the static header as the end anchor

          # 2. Extract content BEFORE the badge block, up to and including the original START_MARKER
             # If the START_MARKER is missing, we re-add it before the new content.
          sed -n '1,/'"$START_MARKER"'/p' README.md > temp_readme.md

             # Check if the START_MARKER was found. If not, the file is currently missing the markers.
             # In this case, we need to create a new START_MARKER before the badge content.
             # If the content is currently missing the markers (like your case):
          if ! grep -q "$START_MARKER" temp_readme.md; then
                 # Fallback: Find the line *before* the badge content and insert START_MARKER
                 # For now, let's just make sure the new content starts with the marker.
              echo "$START_MARKER" > start_marker.txt
              cat start_marker.txt all_badges_content.txt > final_badges_content.txt
          else
                 # If the marker was found, the output of sed already contains it.
              cat all_badges_content.txt >> temp_readme.md
              mv temp_readme.md final_badges_content.txt
          fi
             
             # 3. Use the Table of Contents as the stable END anchor
             # Find the line number of the Table of Contents
          TOC_LINE_NO=$(grep -n "$END_MARKER" README.md | cut -d: -f1)
             # Extract content AFTER the badge block (starting from the TOC line)
          tail -n +$TOC_LINE_NO README.md >> final_badges_content.txt

          # 4. Overwrite the old README
          mv final_badges_content.txt README.md

          # 6. Commit the updated README.md
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git config --global user.name "github-actions[bot]"
          git add README.md
          git commit -m "${{ env.VERSION }} UPDATED Status Badges [skip ci]" || echo "No changes to commit"
          git push

      # -----------------------------------------------------------------
      # END OF ALL README FILE UPDATE WITH BADGES STEPS
      # START OF ALL RELEASE CREATION STEPS
      # -----------------------------------------------------------------
      
  create_release:
    if: contains(github.ref, 'tags/v') # Condition KEPT to only run on tags
    runs-on: ubuntu-latest
    # Now depends on both build and the badge update to ensure release notes are ready
    needs: [build_and_test, update_readme_badges] 

    steps:
      # 1. Checkout README (for release notes)
      # We re-checkout the README here because it might have been updated by the previous job
      - name: Get Readme
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            README.md
            VERSION
          sparse-checkout-cone-mode: false
        
      # 2. Download ALL artifacts from the build_and_test job
      - name: Download Build Artifacts
        uses: actions/download-artifact@v4

      # 3. Compose release notes (using the just-checked-out README)
      - name: Compose release notes
        run: |
          set +e
          echo '![alt text](/Source/Resources/Icons/CtrlrX-README-250x315.png?raw=true "CtrlrX")' > release_notes.txt
          echo -e "\n# CtrlrX ${GITHUB_REF_NAME} - Changelog" >> release_notes.txt
          # The sed command should work on the checked-out README.md
          sed '0,/^## Changelog/d; 0,/^##/d; /##/,$d' README.md >> release_notes.txt
          cat release_notes.txt

      # 4. Create Release
      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          body_path: release_notes.txt
          prerelease: true
          files: |
            CtrlrX-*.exe/*.exe
            CtrlrX-*.zip/*.zip
            CtrlrX-*.pkg/*.pkg
